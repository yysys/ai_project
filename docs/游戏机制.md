# 游戏机制文档 - 拯救菜狗

## 1. 游戏核心机制

### 1.1 基本玩法
游戏场景中，有一个菜狗和一群狼。每个小单位（无论是菜狗还是狼）都有预先定义的四个方向之一。玩家点击单位后，该单位会沿着它预先定义的方向跑动。如果单位跑动到屏幕边界以外，就判断该单位已经消失。

**游戏目标**：玩家需要点击菜狗，让它跑出屏幕边界。菜狗跑出去消失即代表用户获胜。

### 1.2 游戏流程
```
开始游戏 → 生成关卡（菜狗+狼群，每个单位分配固定方向）→ 玩家点击单位 → 单位沿固定方向跑动 → 检测是否跑出屏幕边界 → 判断结果 → 显示结果
```

### 1.3 游戏状态
- **IDLE**: 空闲状态，等待玩家操作
- **RUNNING**: 游戏进行中，单位正在跑动
- **PAUSED**: 游戏暂停
- **WIN**: 游戏胜利（菜狗消失）
- **LOSE**: 游戏失败（菜狗存活）

---

## 2. 角色机制

### 2.1 单位属性（菜狗和狼通用）
```javascript
interface Unit {
  id: string;
  type: UnitType;        // 单位类型（菜狗或狼）
  x: number;              // X坐标
  y: number;              // Y坐标
  size: number;           // 大小
  direction: Direction;    // 预先定义的跑动方向
  speed: number;          // 跑动速度
  state: UnitState;       // 单位状态
  isRunning: boolean;     // 是否正在跑动
  isDisappeared: boolean; // 是否已经消失
}
```

### 2.2 单位类型
```javascript
enum UnitType {
  VEGETABLE_DOG = 'vegetable_dog',  // 菜狗
  WOLF = 'wolf'                          // 狼
}
```

### 2.3 单位状态
```javascript
enum UnitState {
  IDLE = 'idle',         // 空闲
  SELECTED = 'selected', // 选中
  RUNNING = 'running',   // 跑动
  DISAPPEARED = 'disappeared' // 消失
}
```

### 2.4 角色配置
```javascript
const VEGETABLE_DOG_CONFIG = {
  size: 80,              // 菜狗大小
  speed: 100,            // 跑动速度（像素/秒）
  color: '#52C41A',      // 绿色
  position: 'center'      // 屏幕中心
};

const WOLF_CONFIG = {
  size: 60,              // 狼的大小
  speed: 120,            // 跑动速度（像素/秒）
  color: '#FF6B9D',      // 粉色
};
```

---

## 3. 运行方向

### 3.1 四个对角线方向
```javascript
enum Direction {
  LEFT_UP = 'left_up',     // 左上
  LEFT_DOWN = 'left_down', // 左下
  RIGHT_UP = 'right_up',   // 右上
  RIGHT_DOWN = 'right_down' // 右下
}
```

### 3.2 方向向量
```javascript
const DIRECTION_VECTORS = {
  [Direction.LEFT_UP]: { x: -1, y: -1 },
  [Direction.LEFT_DOWN]: { x: -1, y: 1 },
  [Direction.RIGHT_UP]: { x: 1, y: -1 },
  [Direction.RIGHT_DOWN]: { x: 1, y: 1 }
};
```

### 3.3 方向角度
```javascript
const DIRECTION_ANGLES = {
  [Direction.LEFT_UP]: 225,      // 225度
  [Direction.LEFT_DOWN]: 135,    // 135度
  [Direction.RIGHT_UP]: 315,     // 315度
  [Direction.RIGHT_DOWN]: 45     // 45度
};
```

---

## 4. 跑动机制

### 4.1 跑动算法
```javascript
function moveUnit(unit: Unit, deltaTime: number): void {
  if (!unit.isRunning) return;

  const vector = DIRECTION_VECTORS[unit.direction];
  const distance = unit.speed * deltaTime;
  
  // 沿预先定义的对角线移动
  unit.x += vector.x * distance;
  unit.y += vector.y * distance;
}
```

### 4.2 方向分配
```javascript
function assignDirection(unit: Unit): Direction {
  // 随机分配四个方向之一
  const directions = [
    Direction.LEFT_UP,
    Direction.LEFT_DOWN,
    Direction.RIGHT_UP,
    Direction.RIGHT_DOWN
  ];
  
  return directions[Math.floor(Math.random() * directions.length)];
}
```

### 4.3 跑动轨迹
```javascript
interface Trail {
  points: Point[];
  unitId: string;
  timestamp: number;
}

function createTrail(unit: Unit): Trail {
  return {
    points: [{ x: unit.x, y: unit.y }],
    unitId: unit.id,
    timestamp: Date.now()
  };
}

function updateTrail(trail: Trail, unit: Unit): void {
  trail.points.push({ x: unit.x, y: unit.y });
  
  // 限制轨迹点数量
  if (trail.points.length > 30) {
    trail.points.shift();
  }
}
```

---

## 5. 边界检测

### 5.1 边界检测算法
```javascript
function isOutOfBounds(unit: Unit): boolean {
  return (
    unit.x < -unit.size ||
    unit.x > screenWidth + unit.size ||
    unit.y < -unit.size ||
    unit.y > screenHeight + unit.size
  );
}
```

### 5.2 消失判断
```javascript
function checkDisappearance(unit: Unit): boolean {
  if (isOutOfBounds(unit)) {
    unit.isDisappeared = true;
    unit.isRunning = false;
    unit.state = UnitState.DISAPPEARED;
    return true;
  }
  
  // 菜狗跑出屏幕边界即代表胜利
  return isOutOfBounds(unit);
}
```

### 5.3 消失动画
```javascript
function playDisappearAnimation(unit: Unit): void {
  // 播放消失动画
  // 缩放 + 淡出
  unit.scale = 1.3;
  unit.opacity = 0;
  
  setTimeout(() => {
    // 从游戏中移除该单位
    removeUnit(unit.id);
  }, 300);
}
```

---

## 6. 菜狗机制

### 6.1 菜狗生成
```javascript
function createVegetableDog(): Unit {
  const direction = assignDirection();
  
  return {
    id: 'dog_1',
    type: UnitType.VEGETABLE_DOG,
    x: screenWidth / 2,
    y: screenHeight / 2,
    size: VEGETABLE_DOG_CONFIG.size,
    direction: direction,
    speed: VEGETABLE_DOG_CONFIG.speed,
    state: UnitState.IDLE,
    isRunning: false,
    isDisappeared: false
  };
}
```

### 6.2 菜狗消失
```javascript
function vegetableDogDisappeared(dog: Unit): void {
  dog.isDisappeared = true;
  dog.state = UnitState.DISAPPEARED;
  
  // 播放消失动画
  playDisappearAnimation(dog);
  
  // 游戏胜利
  endGame(true);
}
```

---

## 7. 狼机制

### 7.1 狼生成
```javascript
function createWolf(index: number): Unit {
  const direction = assignDirection();
  const position = getRandomPosition();
  
  return {
    id: `wolf_${index}`,
    type: UnitType.WOLF,
    x: position.x,
    y: position.y,
    size: WOLF_CONFIG.size,
    direction: direction,
    speed: WOLF_CONFIG.speed,
    state: UnitState.IDLE,
    isRunning: false,
    isDisappeared: false
  };
}
```

### 7.2 狼消失
```javascript
function wolfDisappeared(wolf: Unit): void {
  wolf.isDisappeared = true;
  wolf.state = UnitState.DISAPPEARED;
  
  // 播放消失动画
  playDisappearAnimation(wolf);
  
  // 从游戏中移除该狼
  removeUnit(wolf.id);
}
```

### 7.3 随机位置生成
```javascript
function getRandomPosition(): { x: number, y: number } {
  // 确保不在屏幕中心（菜狗位置）
  let x, y;
  do {
    x = Math.random() * screenWidth;
    y = Math.random() * screenHeight;
  } while (isNearCenter(x, y));
  
  return { x, y };
}

function isNearCenter(x: number, y: number): boolean {
  const centerX = screenWidth / 2;
  const centerY = screenHeight / 2;
  const distance = Math.sqrt(
    Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2)
  );
  return distance < 150; // 距离中心150像素内
}
```

---

## 8. 关卡机制

### 8.1 关卡属性
```javascript
interface Level {
  id: number;
  name: string;
  type: LevelType;
  dog: Unit;
  wolves: Unit[];
  timeLimit?: number;      // 时间限制（秒）
  targetScore?: number;   // 目标分数
}
```

### 8.2 关卡类型
```javascript
enum LevelType {
  NORMAL = 'normal',     // 普通关卡
  TIMED = 'timed',      // 限时关卡
  SURVIVAL = 'survival', // 生存关卡
  CHALLENGE = 'challenge' // 挑战关卡
}
```

### 8.3 关卡生成
```javascript
function generateLevel(levelConfig: LevelConfig): Level {
  const level: Level = {
    id: levelConfig.id,
    name: levelConfig.name,
    type: levelConfig.type,
    dog: createVegetableDog(),
    wolves: [],
    timeLimit: levelConfig.timeLimit,
    targetScore: levelConfig.targetScore
  };

  // 生成狼群
  level.wolves = generateWolves(levelConfig.wolfCount);

  return level;
}
```

### 8.4 生成狼群
```javascript
function generateWolves(count: number): Unit[] {
  const wolves: Unit[] = [];

  for (let i = 0; i < count; i++) {
    const wolf = createWolf(i);
    wolves.push(wolf);
  }

  return wolves;
}
```

---

## 9. 胜利条件

### 9.1 胜利判断
```javascript
function checkWinCondition(level: Level): boolean {
  // 检查菜狗是否消失（跑出屏幕）
  const dogDisappeared = level.dog.isDisappeared;

  // 菜狗消失即获胜
  return dogDisappeared;
}
```

### 9.2 星级评定
```javascript
function calculateStars(level: Level, timeUsed: number): number {
  let stars = 1;

  // 时间评分
  if (level.timeLimit) {
    const timeRatio = timeUsed / level.timeLimit;
    if (timeRatio < 0.5) stars = 3;
    else if (timeRatio < 0.75) stars = 2;
  }

  // 菜狗消失评分（越快越好）
  if (level.dog.isDisappeared) {
    stars = Math.max(stars, 3);
  }

  return stars;
}
```

---

## 10. 失败条件

### 10.1 失败判断
```javascript
function checkLoseCondition(level: Level): boolean {
  // 检查菜狗是否还存活（没有跑出屏幕）
  const dogAlive = !level.dog.isDisappeared;
  // 检查是否超时
  const timeExceeded = level.timeLimit ? currentTime >= level.timeLimit : false;
  // 菜狗还存活且超时 = 失败
  return dogAlive && timeExceeded;
}
```

---

## 11. 计分系统

### 11.1 基础分数
```javascript
function calculateBaseScore(level: Level): number {
  let score = 0;

  // 狼消失的分数（狼跑出屏幕）
  const wolvesDisappeared = level.wolves.filter(wolf => wolf.isDisappeared).length;
  score += wolvesDisappeared * 100;

  // 菜狗消失奖励（菜狗跑出屏幕即获胜）
  if (level.dog.isDisappeared) {
    score += 500;
  }

  return score;
}
```

### 11.2 时间奖励
```javascript
function calculateTimeBonus(level: Level, timeUsed: number): number {
  if (!level.timeLimit) return 0;

  const timeRemaining = level.timeLimit - timeUsed;
  const bonusPerSecond = 5;

  return Math.floor(timeRemaining * bonusPerSecond);
}
```

---

## 12. 物理引擎

### 12.1 游戏循环
```javascript
function gameLoop(timestamp: number): void {
  const deltaTime = (timestamp - lastTimestamp) / 1000;
  lastTimestamp = timestamp;

  // 更新所有单位的位置
  updateUnits(deltaTime);

  // 检测边界和消失
  checkBoundariesAndDisappearance();

  // 更新游戏状态
  updateGameState();

  // 渲染
  render();

  // 下一帧
  requestAnimationFrame(gameLoop);
}
```

### 12.2 更新单位
```javascript
function updateUnits(deltaTime: number): void {
  allUnits.forEach(unit => {
    if (unit.isRunning) {
      moveUnit(unit, deltaTime);
      updateTrail(unit);
    }
  });
}
```

### 12.3 检测边界和消失
```javascript
function checkBoundariesAndDisappearance(): void {
  allUnits.forEach(unit => {
    if (unit.isRunning && !unit.isDisappeared) {
      if (checkDisappearance(unit)) {
        playDisappearAnimation(unit);
      }
    }
  });
}
```

### 12.4 渲染
```javascript
function render(): void {
  // 清空画布
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 绘制背景
  drawBackground();

  // 绘制所有单位（菜狗和狼）
  allUnits.forEach(unit => {
    if (!unit.isDisappeared) {
      drawUnit(unit);
    }
  });

  // 绘制轨迹
  trails.forEach(trail => {
    drawTrail(trail);
  });

  // 绘制UI
  drawUI();
}
```

---

## 13. 性能优化

### 13.1 对象池
```javascript
class ObjectPool<T> {
  private pool: T[] = [];
  private factory: () => T;

  constructor(factory: () => T, initialSize: number = 10) {
    this.factory = factory;
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(factory());
    }
  }

  acquire(): T {
    return this.pool.pop() || this.factory();
  }

  release(obj: T): void {
    this.pool.push(obj);
  }
}
```

### 13.2 空间分区
```javascript
class SpatialPartition {
  private grid: Map<string, Entity[]> = new Map();
  private cellSize: number;

  constructor(cellSize: number = 100) {
    this.cellSize = cellSize;
  }

  add(entity: Entity): void {
    const key = this.getKey(entity);
    if (!this.grid.has(key)) {
      this.grid.set(key, []);
    }
    this.grid.get(key)!.push(entity);
  }

  getNearby(entity: Entity): Entity[] {
    const key = this.getKey(entity);
    return this.grid.get(key) || [];
  }

  private getKey(entity: Entity): string {
    const x = Math.floor(entity.x / this.cellSize);
    const y = Math.floor(entity.y / this.cellSize);
    return `${x},${y}`;
  }
}
```

### 13.3 帧率控制
```javascript
class FrameRateController {
  private targetFPS: number = 60;
  private frameTime: number = 1000 / this.targetFPS;
  private lastTime: number = 0;

  update(callback: () => void): void {
    const currentTime = performance.now();
    const deltaTime = currentTime - this.lastTime;

    if (deltaTime >= this.frameTime) {
      this.lastTime = currentTime - (deltaTime % this.frameTime);
      callback();
    }

    requestAnimationFrame(() => this.update(callback));
  }
}
```

---

## 14. 数据持久化

### 14.1 保存游戏进度
```javascript
function saveGameProgress(progress: GameProgress): void {
  const data = JSON.stringify(progress);
  localStorage.setItem('gameProgress', data);
}
```

### 14.2 加载游戏进度
```javascript
function loadGameProgress(): GameProgress | null {
  const data = localStorage.getItem('gameProgress');
  if (!data) return null;

  try {
    return JSON.parse(data);
  } catch (error) {
    return null;
  }
}
```

### 14.3 游戏进度结构
```javascript
interface GameProgress {
  currentLevel: number;
  unlockedLevels: number[];
  highScores: Map<number, number>;
  totalScore: number;
  coins: number;
  unlockedSkins: string[];
  settings: GameSettings;
}
```

---

## 15. 特殊机制

### 15.1 点击反馈
```javascript
function handleClick(unit: Unit): void {
  // 播放点击动画
  unit.scale = 1.2;
  setTimeout(() => {
    unit.scale = 1;
  }, 150);

  // 开始跑动
  unit.isRunning = true;
  unit.state = UnitState.RUNNING;
}
```

### 15.2 消失效果
```javascript
function createDisappearEffect(unit: Unit): void {
  // 创建消失粒子效果
  const particles = [];
  for (let i = 0; i < 10; i++) {
    particles.push({
      x: unit.x,
      y: unit.y,
      vx: (Math.random() - 0.5) * 5,
      vy: (Math.random() - 0.5) * 5,
      life: 1.0
    });
  }

  // 更新粒子
  function updateParticles() {
    particles.forEach(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.life -= 0.05;
    });

    // 移除消失的粒子
    particles = particles.filter(p => p.life > 0);

    if (particles.length > 0) {
      requestAnimationFrame(updateParticles);
    }
  }

  updateParticles();
}
```

---

**文档版本**：v2.0
**最后更新**：2026-02-08
**负责人**：开发团队
