# 游戏机制文档 - 猪了个猪

## 1. 游戏核心机制

### 1.1 基本玩法
玩家通过点击屏幕上的猪猪，让它们沿着直线跑动，完成各种任务和挑战。

### 1.2 游戏流程
```
开始游戏 → 生成关卡 → 玩家点击猪猪 → 猪猪跑动 → 碰撞检测 → 判断结果 → 显示结果
```

### 1.3 游戏状态
- **IDLE**: 空闲状态，等待玩家操作
- **RUNNING**: 游戏进行中，猪猪正在跑动
- **PAUSED**: 游戏暂停
- **WIN**: 游戏胜利
- **LOSE**: 游戏失败

---

## 2. 猪猪机制

### 2.1 猪猪属性
```javascript
class Pig {
  id: string;              // 猪猪唯一标识
  type: PigType;          // 猪猪类型
  x: number;              // X坐标
  y: number;              // Y坐标
  direction: Direction;    // 跑动方向
  speed: number;          // 跑动速度
  state: PigState;        // 猪猪状态
  isRunning: boolean;     // 是否正在跑动
  hasReachedGoal: boolean;// 是否到达目标
}
```

### 2.2 猪猪类型
```javascript
enum PigType {
  NORMAL = 'normal',      // 普通猪猪
  FAST = 'fast',         // 快速猪猪
  JUMP = 'jump',         // 跳跃猪猪
  BOMB = 'bomb',         // 炸弹猪猪
  MAGNET = 'magnet'      // 磁铁猪猪
}
```

### 2.3 猪猪状态
```javascript
enum PigState {
  IDLE = 'idle',         // 空闲
  SELECTED = 'selected', // 选中
  RUNNING = 'running',   // 跑动
  JUMPING = 'jumping',   // 跳跃中
  EXPLODING = 'exploding', // 爆炸中
  REACHED = 'reached',   // 到达目标
  FAILED = 'failed'      // 失败
}
```

### 2.4 猪猪配置
```javascript
const PIG_CONFIG = {
  [PigType.NORMAL]: {
    speed: 100,          // 像素/秒
    size: 60,
    color: '#FF6B9D',
    canJump: false,
    canExplode: false,
    canMagnet: false
  },
  [PigType.FAST]: {
    speed: 150,          // 1.5倍速度
    size: 60,
    color: '#FFD93D',
    canJump: false,
    canExplode: false,
    canMagnet: false
  },
  [PigType.JUMP]: {
    speed: 100,
    size: 60,
    color: '#52C41A',
    canJump: true,
    canExplode: false,
    canMagnet: false
  },
  [PigType.BOMB]: {
    speed: 100,
    size: 60,
    color: '#F5222D',
    canJump: false,
    canExplode: true,
    canMagnet: false
  },
  [PigType.MAGNET]: {
    speed: 100,
    size: 60,
    color: '#1890FF',
    canJump: false,
    canExplode: false,
    canMagnet: true
  }
};
```

---

## 3. 跑动机制

### 3.1 跑动方向
```javascript
enum Direction {
  UP = 'up',
  DOWN = 'down',
  LEFT = 'left',
  RIGHT = 'right'
}
```

### 3.2 跑动算法
```javascript
function movePig(pig: Pig, deltaTime: number): void {
  if (!pig.isRunning) return;

  const distance = pig.speed * deltaTime;
  
  switch (pig.direction) {
    case Direction.UP:
      pig.y -= distance;
      break;
    case Direction.DOWN:
      pig.y += distance;
      break;
    case Direction.LEFT:
      pig.x -= distance;
      break;
    case Direction.RIGHT:
      pig.x += distance;
      break;
  }
}
```

### 3.3 跑动轨迹
```javascript
interface Trail {
  points: Point[];
  pigId: string;
  timestamp: number;
}

function createTrail(pig: Pig): Trail {
  return {
    points: [{ x: pig.x, y: pig.y }],
    pigId: pig.id,
    timestamp: Date.now()
  };
}

function updateTrail(trail: Trail, pig: Pig): void {
  trail.points.push({ x: pig.x, y: pig.y });
  
  // 限制轨迹点数量
  if (trail.points.length > 50) {
    trail.points.shift();
  }
}
```

---

## 4. 碰撞检测

### 4.1 碰撞类型
- **边界碰撞**: 猪猪碰到屏幕边界
- **障碍物碰撞**: 猪猪碰到障碍物
- **目标碰撞**: 猪猪到达目标区域
- **道具碰撞**: 猪猪碰到道具

### 4.2 碰撞检测算法
```javascript
function checkCollision(pig: Pig, obstacles: Obstacle[]): CollisionResult {
  // 边界检测
  if (isOutOfBounds(pig)) {
    return {
      type: 'boundary',
      pigId: pig.id,
      position: { x: pig.x, y: pig.y }
    };
  }

  // 障碍物检测
  for (const obstacle of obstacles) {
    if (isColliding(pig, obstacle)) {
      return {
        type: 'obstacle',
        pigId: pig.id,
        obstacleId: obstacle.id,
        position: { x: pig.x, y: pig.y }
      };
    }
  }

  // 目标检测
  if (isInGoal(pig)) {
    return {
      type: 'goal',
      pigId: pig.id,
      position: { x: pig.x, y: pig.y }
    };
  }

  return null;
}
```

### 4.3 圆形碰撞检测
```javascript
function isColliding(circle1: Circle, circle2: Circle): boolean {
  const dx = circle1.x - circle2.x;
  const dy = circle1.y - circle2.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  return distance < circle1.radius + circle2.radius;
}
```

### 4.4 矩形碰撞检测
```javascript
function isColliding(rect1: Rectangle, rect2: Rectangle): boolean {
  return (
    rect1.x < rect2.x + rect2.width &&
    rect1.x + rect1.width > rect2.x &&
    rect1.y < rect2.y + rect2.height &&
    rect1.y + rect1.height > rect2.y
  );
}
```

---

## 5. 障碍物机制

### 5.1 障碍物类型
```javascript
enum ObstacleType {
  ROCK = 'rock',         // 石头
  PUDDLE = 'puddle',     // 水坑
  TRAP = 'trap',         // 陷阱
  SPRING = 'spring'      // 弹簧
}
```

### 5.2 障碍物属性
```javascript
interface Obstacle {
  id: string;
  type: ObstacleType;
  x: number;
  y: number;
  width: number;
  height: number;
  isDestructible: boolean;  // 是否可破坏
  isPassable: boolean;       // 是否可通过
}
```

### 5.3 障碍物配置
```javascript
const OBSTACLE_CONFIG = {
  [ObstacleType.ROCK]: {
    width: 80,
    height: 80,
    isDestructible: false,
    isPassable: false
  },
  [ObstacleType.PUDDLE]: {
    width: 100,
    height: 60,
    isDestructible: false,
    isPassable: true  // 跳跃猪猪可通过
  },
  [ObstacleType.TRAP]: {
    width: 60,
    height: 60,
    isDestructible: false,
    isPassable: false
  },
  [ObstacleType.SPRING]: {
    width: 50,
    height: 80,
    isDestructible: false,
    isPassable: true
  }
};
```

---

## 6. 道具机制

### 6.1 道具类型
```javascript
enum ItemType {
  STAR = 'star',         // 星星
  COIN = 'coin',         // 金币
  GEM = 'gem',           // 宝石
  KEY = 'key'            // 钥匙
}
```

### 6.2 道具属性
```javascript
interface Item {
  id: string;
  type: ItemType;
  x: number;
  y: number;
  value: number;         // 道具价值
  isCollected: boolean;  // 是否已收集
}
```

### 6.3 道具收集
```javascript
function collectItem(pig: Pig, item: Item): void {
  if (item.isCollected) return;

  item.isCollected = true;
  
  // 磁铁猪猪吸引附近道具
  if (pig.type === PigType.MAGNET) {
    attractNearbyItems(pig);
  }

  // 更新分数
  updateScore(item.value);

  // 播放收集动画
  playCollectAnimation(item);
}
```

### 6.4 磁铁吸引机制
```javascript
function attractNearbyItems(pig: Pig): void {
  const magnetRange = 150; // 磁铁范围
  
  items.forEach(item => {
    if (item.isCollected) return;

    const distance = getDistance(pig, item);
    if (distance < magnetRange) {
      // 移动道具向猪猪
      moveItemTowardsPig(item, pig);
    }
  });
}
```

---

## 7. 特殊能力机制

### 7.1 跳跃能力
```javascript
function jumpOverObstacle(pig: Pig, obstacle: Obstacle): void {
  if (pig.type !== PigType.JUMP) return;
  if (obstacle.type !== ObstacleType.PUDDLE) return;

  // 跳跃动画
  playJumpAnimation(pig);

  // 跳跃过程中不进行碰撞检测
  pig.state = PigState.JUMPING;

  // 跳跃持续时间
  setTimeout(() => {
    pig.state = PigState.RUNNING;
  }, 500);
}
```

### 7.2 爆炸能力
```javascript
function explodeObstacle(pig: Pig, obstacle: Obstacle): void {
  if (pig.type !== PigType.BOMB) return;
  if (!obstacle.isDestructible) return;

  // 爆炸动画
  playExplosionAnimation(obstacle);

  // 移除障碍物
  removeObstacle(obstacle);

  // 爆炸范围
  const explosionRange = 100;
  destroyNearbyObstacles(obstacle, explosionRange);
}
```

### 7.3 弹簧反弹
```javascript
function bounceOnSpring(pig: Pig, spring: Obstacle): void {
  if (spring.type !== ObstacleType.SPRING) return;

  // 反弹动画
  playBounceAnimation(pig);

  // 改变方向
  pig.direction = getOppositeDirection(pig.direction);

  // 增加速度
  pig.speed *= 1.5;

  // 持续时间后恢复速度
  setTimeout(() => {
    pig.speed = PIG_CONFIG[pig.type].speed;
  }, 1000);
}
```

---

## 8. 关卡机制

### 8.1 关卡属性
```javascript
interface Level {
  id: number;
  name: string;
  type: LevelType;
  pigs: Pig[];
  obstacles: Obstacle[];
  items: Item[];
  goals: Goal[];
  timeLimit?: number;  // 时间限制（秒）
  targetScore?: number; // 目标分数
}
```

### 8.2 关卡类型
```javascript
enum LevelType {
  NORMAL = 'normal',     // 普通关卡
  OBSTACLE = 'obstacle', // 障碍关卡
  COLLECT = 'collect',   // 收集关卡
  TIMED = 'timed',      // 限时关卡
  CHALLENGE = 'challenge' // 挑战关卡
}
```

### 8.3 关卡生成
```javascript
function generateLevel(levelConfig: LevelConfig): Level {
  const level: Level = {
    id: levelConfig.id,
    name: levelConfig.name,
    type: levelConfig.type,
    pigs: [],
    obstacles: [],
    items: [],
    goals: []
  };

  // 生成猪猪
  level.pigs = generatePigs(levelConfig.pigCount, levelConfig.pigTypes);

  // 生成障碍物
  level.obstacles = generateObstacles(levelConfig.obstacleCount, levelConfig.obstacleTypes);

  // 生成道具
  level.items = generateItems(levelConfig.itemCount, levelConfig.itemTypes);

  // 生成目标
  level.goals = generateGoals(levelConfig.goalCount);

  // 设置时间限制
  if (levelConfig.type === LevelType.TIMED) {
    level.timeLimit = levelConfig.timeLimit;
  }

  return level;
}
```

### 8.4 关卡验证
```javascript
function validateLevel(level: Level): boolean {
  // 检查猪猪数量
  if (level.pigs.length === 0) return false;

  // 检查目标数量
  if (level.goals.length === 0) return false;

  // 检查猪猪类型配置
  for (const pig of level.pigs) {
    if (!PIG_CONFIG[pig.type]) return false;
  }

  // 检查障碍物配置
  for (const obstacle of level.obstacles) {
    if (!OBSTACLE_CONFIG[obstacle.type]) return false;
  }

  // 检查道具配置
  for (const item of level.items) {
    if (!ITEM_CONFIG[item.type]) return false;
  }

  return true;
}
```

---

## 9. 胜利条件

### 9.1 胜利判断
```javascript
function checkWinCondition(level: Level): boolean {
  // 检查所有猪猪是否到达目标
  const allPigsReachedGoal = level.pigs.every(pig => pig.hasReachedGoal);

  // 检查是否达到目标分数
  const reachedTargetScore = level.targetScore ? currentScore >= level.targetScore : true;

  // 检查是否收集到指定道具
  const collectedRequiredItems = level.items.filter(item => item.isCollected).length >= level.items.length;

  return allPigsReachedGoal && reachedTargetScore && collectedRequiredItems;
}
```

### 9.2 星级评定
```javascript
function calculateStars(level: Level, timeUsed: number): number {
  let stars = 1;

  // 时间评分
  if (level.timeLimit) {
    const timeRatio = timeUsed / level.timeLimit;
    if (timeRatio < 0.5) stars = 3;
    else if (timeRatio < 0.75) stars = 2;
  }

  // 收集评分
  const collectedItems = level.items.filter(item => item.isCollected).length;
  const itemRatio = collectedItems / level.items.length;
  if (itemRatio === 1) stars = Math.max(stars, 3);
  else if (itemRatio >= 0.8) stars = Math.max(stars, 2);

  return stars;
}
```

---

## 10. 失败条件

### 10.1 失败判断
```javascript
function checkLoseCondition(level: Level): boolean {
  // 检查是否有猪猪碰到陷阱
  const pigHitTrap = level.pigs.some(pig => pig.state === PigState.FAILED);

  // 检查是否超时
  const timeExceeded = level.timeLimit ? currentTime >= level.timeLimit : false;

  // 检查是否有猪猪卡住
  const pigStuck = level.pigs.some(pig => {
    return pig.isRunning && !pig.hasReachedGoal && isPigStuck(pig);
  });

  return pigHitTrap || timeExceeded || pigStuck;
}
```

### 10.2 卡住检测
```javascript
function isPigStuck(pig: Pig): boolean {
  // 检查猪猪是否在相同位置停留过长时间
  const stuckTime = 3000; // 3秒
  const currentTime = Date.now();
  
  if (!pig.lastMoveTime) {
    pig.lastMoveTime = currentTime;
    return false;
  }

  const timeSinceLastMove = currentTime - pig.lastMoveTime;
  return timeSinceLastMove > stuckTime;
}
```

---

## 11. 计分系统

### 11.1 基础分数
```javascript
function calculateBaseScore(level: Level): number {
  let score = 0;

  // 猪猪到达目标分数
  const pigsReachedGoal = level.pigs.filter(pig => pig.hasReachedGoal).length;
  score += pigsReachedGoal * 100;

  // 道具收集分数
  const collectedItems = level.items.filter(item => item.isCollected);
  collectedItems.forEach(item => {
    score += item.value;
  });

  return score;
}
```

### 11.2 时间奖励
```javascript
function calculateTimeBonus(level: Level, timeUsed: number): number {
  if (!level.timeLimit) return 0;

  const timeRemaining = level.timeLimit - timeUsed;
  const bonusPerSecond = 10;

  return Math.floor(timeRemaining * bonusPerSecond);
}
```

### 11.3 完美奖励
```javascript
function calculatePerfectBonus(level: Level): number {
  // 所有猪猪到达目标
  const allPigsReachedGoal = level.pigs.every(pig => pig.hasReachedGoal);
  
  // 所有道具被收集
  const allItemsCollected = level.items.every(item => item.isCollected);

  if (allPigsReachedGoal && allItemsCollected) {
    return 500;
  }

  return 0;
}
```

---

## 12. 物理引擎

### 12.1 游戏循环
```javascript
function gameLoop(timestamp: number): void {
  const deltaTime = (timestamp - lastTimestamp) / 1000;
  lastTimestamp = timestamp;

  // 更新猪猪位置
  updatePigs(deltaTime);

  // 碰撞检测
  checkCollisions();

  // 更新游戏状态
  updateGameState();

  // 渲染
  render();

  // 下一帧
  requestAnimationFrame(gameLoop);
}
```

### 12.2 更新猪猪
```javascript
function updatePigs(deltaTime: number): void {
  pigs.forEach(pig => {
    if (pig.isRunning) {
      movePig(pig, deltaTime);
      updateTrail(pig);
      pig.lastMoveTime = Date.now();
    }
  });
}
```

### 12.3 渲染
```javascript
function render(): void {
  // 清空画布
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 绘制背景
  drawBackground();

  // 绘制障碍物
  obstacles.forEach(obstacle => {
    drawObstacle(obstacle);
  });

  // 绘制道具
  items.forEach(item => {
    if (!item.isCollected) {
      drawItem(item);
    }
  });

  // 绘制目标
  goals.forEach(goal => {
    drawGoal(goal);
  });

  // 绘制猪猪
  pigs.forEach(pig => {
    drawPig(pig);
  });

  // 绘制轨迹
  trails.forEach(trail => {
    drawTrail(trail);
  });
}
```

---

## 13. 性能优化

### 13.1 对象池
```javascript
class ObjectPool<T> {
  private pool: T[] = [];
  private factory: () => T;

  constructor(factory: () => T, initialSize: number = 10) {
    this.factory = factory;
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(factory());
    }
  }

  acquire(): T {
    return this.pool.pop() || this.factory();
  }

  release(obj: T): void {
    this.pool.push(obj);
  }
}
```

### 13.2 空间分区
```javascript
class SpatialPartition {
  private grid: Map<string, Entity[]> = new Map();
  private cellSize: number;

  constructor(cellSize: number = 100) {
    this.cellSize = cellSize;
  }

  add(entity: Entity): void {
    const key = this.getKey(entity);
    if (!this.grid.has(key)) {
      this.grid.set(key, []);
    }
    this.grid.get(key)!.push(entity);
  }

  getNearby(entity: Entity): Entity[] {
    const key = this.getKey(entity);
    return this.grid.get(key) || [];
  }

  private getKey(entity: Entity): string {
    const x = Math.floor(entity.x / this.cellSize);
    const y = Math.floor(entity.y / this.cellSize);
    return `${x},${y}`;
  }
}
```

### 13.3 帧率控制
```javascript
class FrameRateController {
  private targetFPS: number = 60;
  private frameTime: number = 1000 / this.targetFPS;
  private lastTime: number = 0;

  update(callback: () => void): void {
    const currentTime = performance.now();
    const deltaTime = currentTime - this.lastTime;

    if (deltaTime >= this.frameTime) {
      this.lastTime = currentTime - (deltaTime % this.frameTime);
      callback();
    }

    requestAnimationFrame(() => this.update(callback));
  }
}
```

---

## 14. 数据持久化

### 14.1 保存游戏进度
```javascript
function saveGameProgress(progress: GameProgress): void {
  const data = JSON.stringify(progress);
  localStorage.setItem('gameProgress', data);
}
```

### 14.2 加载游戏进度
```javascript
function loadGameProgress(): GameProgress | null {
  const data = localStorage.getItem('gameProgress');
  if (!data) return null;

  try {
    return JSON.parse(data);
  } catch (error) {
    return null;
  }
}
```

### 14.3 游戏进度结构
```javascript
interface GameProgress {
  currentLevel: number;
  unlockedLevels: number[];
  highScores: Map<number, number>;
  totalScore: number;
  coins: number;
  gems: number;
  unlockedSkins: string[];
  settings: GameSettings;
}
```

---

**文档版本**：v1.0
**最后更新**：2026-02-01
**负责人**：开发团队
