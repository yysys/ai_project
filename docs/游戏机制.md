# 游戏机制文档 - 猪了个猪（菜狗与狼群版）

## 1. 游戏核心机制

### 1.1 基本玩法
游戏场景中，中间有一个菜狗，周围有一群狼。玩家点击狼，狼会沿着对角线方向（左上、左下、右上、右下）跑动，目标是保护菜狗不被狼抓到。

### 1.2 游戏流程
```
开始游戏 → 生成关卡（菜狗+狼群）→ 玩家点击狼 → 狼沿对角线跑动 → 碰撞检测 → 判断结果 → 显示结果
```

### 1.3 游戏状态
- **IDLE**: 空闲状态，等待玩家操作
- **RUNNING**: 游戏进行中，狼正在跑动
- **PAUSED**: 游戏暂停
- **WIN**: 游戏胜利（菜狗存活）
- **LOSE**: 游戏失败（菜狗被抓）

---

## 2. 角色机制

### 2.1 菜狗（主角）
```javascript
interface VegetableDog {
  id: string;
  x: number;              // X坐标（屏幕中心）
  y: number;              // Y坐标（屏幕中心）
  size: number;           // 大小
  health: number;         // 生命值
  state: DogState;        // 狗的状态
  isProtected: boolean;   // 是否被保护
}
```

### 2.2 狼（敌人）
```javascript
interface Wolf {
  id: string;
  x: number;              // X坐标
  y: number;              // Y坐标
  size: number;           // 大小
  direction: Direction;    // 跑动方向
  speed: number;          // 跑动速度
  state: WolfState;       // 狼的状态
  isRunning: boolean;     // 是否正在跑动
  hasCaughtDog: boolean;  // 是否抓到菜狗
}
```

### 2.3 菜狗状态
```javascript
enum DogState {
  IDLE = 'idle',         // 空闲
  SCARED = 'scared',     // 害怕
  PROTECTED = 'protected', // 被保护
  CAUGHT = 'caught'       // 被抓
}
```

### 2.4 狼的状态
```javascript
enum WolfState {
  IDLE = 'idle',         // 空闲
  SELECTED = 'selected', // 选中
  RUNNING = 'running',   // 跑动
  HUNTING = 'hunting',   // 狩猎中
  CAUGHT = 'caught'      // 抓到菜狗
}
```

### 2.5 角色配置
```javascript
const DOG_CONFIG = {
  size: 80,              // 菜狗大小
  health: 3,             // 生命值
  color: '#52C41A',      // 绿色
  position: 'center'      // 屏幕中心
};

const WOLF_CONFIG = {
  size: 60,              // 狼的大小
  speed: 120,            // 跑动速度（像素/秒）
  color: '#FF6B9D',      // 粉色
  damage: 1              // 伤害值
};
```

---

## 3. 运行方向

### 3.1 四个对角线方向
```javascript
enum Direction {
  LEFT_UP = 'left_up',     // 左上
  LEFT_DOWN = 'left_down', // 左下
  RIGHT_UP = 'right_up',   // 右上
  RIGHT_DOWN = 'right_down' // 右下
}
```

### 3.2 方向向量
```javascript
const DIRECTION_VECTORS = {
  [Direction.LEFT_UP]: { x: -1, y: -1 },
  [Direction.LEFT_DOWN]: { x: -1, y: 1 },
  [Direction.RIGHT_UP]: { x: 1, y: -1 },
  [Direction.RIGHT_DOWN]: { x: 1, y: 1 }
};
```

### 3.3 方向角度
```javascript
const DIRECTION_ANGLES = {
  [Direction.LEFT_UP]: 225,      // 225度
  [Direction.LEFT_DOWN]: 135,    // 135度
  [Direction.RIGHT_UP]: 315,     // 315度
  [Direction.RIGHT_DOWN]: 45     // 45度
};
```

---

## 4. 跑动机制

### 4.1 跑动算法
```javascript
function moveWolf(wolf: Wolf, deltaTime: number): void {
  if (!wolf.isRunning) return;

  const vector = DIRECTION_VECTORS[wolf.direction];
  const distance = wolf.speed * deltaTime;
  
  // 沿对角线移动
  wolf.x += vector.x * distance;
  wolf.y += vector.y * distance;
}
```

### 4.2 方向选择
```javascript
function selectDirection(wolf: Wolf, dog: VegetableDog): Direction {
  // 计算狼到菜狗的方向
  const dx = dog.x - wolf.x;
  const dy = dog.y - wolf.y;

  // 根据相对位置选择方向
  if (dx < 0 && dy < 0) return Direction.LEFT_UP;
  if (dx < 0 && dy > 0) return Direction.LEFT_DOWN;
  if (dx > 0 && dy < 0) return Direction.RIGHT_UP;
  if (dx > 0 && dy > 0) return Direction.RIGHT_DOWN;

  return Direction.LEFT_UP; // 默认方向
}
```

### 4.3 跑动轨迹
```javascript
interface Trail {
  points: Point[];
  wolfId: string;
  timestamp: number;
}

function createTrail(wolf: Wolf): Trail {
  return {
    points: [{ x: wolf.x, y: wolf.y }],
    wolfId: wolf.id,
    timestamp: Date.now()
  };
}

function updateTrail(trail: Trail, wolf: Wolf): void {
  trail.points.push({ x: wolf.x, y: wolf.y });
  
  // 限制轨迹点数量
  if (trail.points.length > 30) {
    trail.points.shift();
  }
}
```

---

## 5. 碰撞检测

### 5.1 碰撞类型
- **边界碰撞**: 狼碰到屏幕边界
- **菜狗碰撞**: 狼碰到菜狗
- **狼与狼碰撞**: 狼与狼之间的碰撞

### 5.2 碰撞检测算法
```javascript
function checkCollision(wolf: Wolf, dog: VegetableDog): CollisionResult {
  // 边界检测
  if (isOutOfBounds(wolf)) {
    return {
      type: 'boundary',
      wolfId: wolf.id,
      position: { x: wolf.x, y: wolf.y }
    };
  }

  // 菜狗检测
  if (isColliding(wolf, dog)) {
    return {
      type: 'dog',
      wolfId: wolf.id,
      dogId: dog.id,
      position: { x: wolf.x, y: wolf.y }
    };
  }

  return null;
}
```

### 5.3 圆形碰撞检测
```javascript
function isColliding(circle1: Circle, circle2: Circle): boolean {
  const dx = circle1.x - circle2.x;
  const dy = circle1.y - circle2.y;
  const distance = Math.sqrt(dx * dx + dy * dy);
  return distance < circle1.radius + circle2.radius;
}
```

### 5.4 边界检测
```javascript
function isOutOfBounds(wolf: Wolf): boolean {
  return (
    wolf.x < 0 ||
    wolf.x > screenWidth ||
    wolf.y < 0 ||
    wolf.y > screenHeight
  );
}
```

---

## 6. 菜狗保护机制

### 6.1 保护状态
```javascript
function protectDog(dog: VegetableDog, duration: number): void {
  dog.isProtected = true;
  dog.state = DogState.PROTECTED;

  // 保护持续时间
  setTimeout(() => {
    dog.isProtected = false;
    dog.state = DogState.IDLE;
  }, duration);
}
```

### 6.2 菜狗受伤
```javascript
function hurtDog(dog: VegetableDog, wolf: Wolf): void {
  if (dog.isProtected) return;

  dog.health -= WOLF_CONFIG.damage;
  dog.state = DogState.SCARED;

  // 检查菜狗是否被抓
  if (dog.health <= 0) {
    dog.state = DogState.CAUGHT;
    wolf.hasCaughtDog = true;
  }
}
```

### 6.3 菜狗恢复
```javascript
function healDog(dog: VegetableDog, amount: number): void {
  dog.health = Math.min(dog.health + amount, DOG_CONFIG.health);
  
  if (dog.state === DogState.SCARED) {
    dog.state = DogState.IDLE;
  }
}
```

---

## 7. 狼的行为机制

### 7.1 狼的AI
```javascript
function updateWolfAI(wolf: Wolf, dog: VegetableDog): void {
  if (wolf.isRunning) return;

  // 计算到菜狗的距离
  const distance = getDistance(wolf, dog);

  // 如果距离较近，开始追逐
  if (distance < 300) {
    wolf.state = WolfState.HUNTING;
    wolf.direction = selectDirection(wolf, dog);
  }
}
```

### 7.2 狼的追逐
```javascript
function chaseDog(wolf: Wolf, dog: VegetableDog): void {
  if (wolf.state !== WolfState.HUNTING) return;

  // 更新方向，始终朝向菜狗
  wolf.direction = selectDirection(wolf, dog);

  // 开始跑动
  wolf.isRunning = true;
  wolf.state = WolfState.RUNNING;
}
```

### 7.3 狼的停止
```javascript
function stopWolf(wolf: Wolf): void {
  wolf.isRunning = false;
  wolf.state = WolfState.IDLE;
}
```

---

## 8. 关卡机制

### 8.1 关卡属性
```javascript
interface Level {
  id: number;
  name: string;
  type: LevelType;
  dog: VegetableDog;
  wolves: Wolf[];
  timeLimit?: number;      // 时间限制（秒）
  targetScore?: number;   // 目标分数
  obstacles?: Obstacle[]; // 障碍物（可选）
}
```

### 8.2 关卡类型
```javascript
enum LevelType {
  NORMAL = 'normal',     // 普通关卡
  TIMED = 'timed',      // 限时关卡
  SURVIVAL = 'survival', // 生存关卡
  CHALLENGE = 'challenge' // 挑战关卡
}
```

### 8.3 关卡生成
```javascript
function generateLevel(levelConfig: LevelConfig): Level {
  const level: Level = {
    id: levelConfig.id,
    name: levelConfig.name,
    type: levelConfig.type,
    dog: createDog(),
    wolves: [],
    timeLimit: levelConfig.timeLimit,
    targetScore: levelConfig.targetScore
  };

  // 生成狼群
  level.wolves = generateWolves(levelConfig.wolfCount);

  // 生成障碍物（可选）
  if (levelConfig.obstacles) {
    level.obstacles = generateObstacles(levelConfig.obstacleCount);
  }

  return level;
}
```

### 8.4 生成菜狗
```javascript
function createDog(): VegetableDog {
  return {
    id: 'dog_1',
    x: screenWidth / 2,
    y: screenHeight / 2,
    size: DOG_CONFIG.size,
    health: DOG_CONFIG.health,
    state: DogState.IDLE,
    isProtected: false
  };
}
```

### 8.5 生成狼群
```javascript
function generateWolves(count: number): Wolf[] {
  const wolves: Wolf[] = [];

  for (let i = 0; i < count; i++) {
    const wolf: Wolf = {
      id: `wolf_${i}`,
      x: getRandomPosition(),
      y: getRandomPosition(),
      size: WOLF_CONFIG.size,
      direction: getRandomDirection(),
      speed: WOLF_CONFIG.speed,
      state: WolfState.IDLE,
      isRunning: false,
      hasCaughtDog: false
    };

    wolves.push(wolf);
  }

  return wolves;
}
```

### 8.6 随机位置生成
```javascript
function getRandomPosition(): number {
  // 确保不在屏幕中心（菜狗位置）
  let x, y;
  do {
    x = Math.random() * screenWidth;
    y = Math.random() * screenHeight;
  } while (isNearCenter(x, y));

  return x;
}

function isNearCenter(x: number, y: number): boolean {
  const centerX = screenWidth / 2;
  const centerY = screenHeight / 2;
  const distance = Math.sqrt(
    Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2)
  );
  return distance < 150; // 距离中心150像素内
}
```

---

## 9. 胜利条件

### 9.1 胜利判断
```javascript
function checkWinCondition(level: Level): boolean {
  // 检查菜狗是否存活
  const dogAlive = level.dog.health > 0;

  // 检查是否达到目标分数
  const reachedTargetScore = level.targetScore ? currentScore >= level.targetScore : true;

  // 检查是否所有狼都被消灭或赶走
  const allWolvesGone = level.wolves.every(wolf => 
    wolf.hasCaughtDog || isOutOfBounds(wolf)
  );

  return dogAlive && reachedTargetScore && allWolvesGone;
}
```

### 9.2 星级评定
```javascript
function calculateStars(level: Level, timeUsed: number, dogHealth: number): number {
  let stars = 1;

  // 时间评分
  if (level.timeLimit) {
    const timeRatio = timeUsed / level.timeLimit;
    if (timeRatio < 0.5) stars = 3;
    else if (timeRatio < 0.75) stars = 2;
  }

  // 菜狗生命值评分
  const healthRatio = dogHealth / DOG_CONFIG.health;
  if (healthRatio === 1) stars = Math.max(stars, 3);
  else if (healthRatio >= 0.7) stars = Math.max(stars, 2);

  return stars;
}
```

---

## 10. 失败条件

### 10.1 失败判断
```javascript
function checkLoseCondition(level: Level): boolean {
  // 检查菜狗是否被抓
  const dogCaught = level.dog.state === DogState.CAUGHT;

  // 检查是否超时
  const timeExceeded = level.timeLimit ? currentTime >= level.timeLimit : false;

  return dogCaught || timeExceeded;
}
```

### 10.2 菜狗被抓
```javascript
function dogCaught(dog: VegetableDog, wolf: Wolf): void {
  dog.state = DogState.CAUGHT;
  wolf.hasCaughtDog = true;
  wolf.state = WolfState.CAUGHT;

  // 播放被抓动画
  playCaughtAnimation(dog, wolf);

  // 游戏结束
  endGame(false);
}
```

---

## 11. 计分系统

### 11.1 基础分数
```javascript
function calculateBaseScore(level: Level): number {
  let score = 0;

  // 赶走狼的分数
  const wolvesGone = level.wolves.filter(wolf => isOutOfBounds(wolf)).length;
  score += wolvesGone * 100;

  // 菜狗存活奖励
  if (level.dog.health > 0) {
    score += 500;
  }

  return score;
}
```

### 11.2 生命值奖励
```javascript
function calculateHealthBonus(dog: VegetableDog): number {
  const healthRatio = dog.health / DOG_CONFIG.health;
  return Math.floor(healthRatio * 200);
}
```

### 11.3 时间奖励
```javascript
function calculateTimeBonus(level: Level, timeUsed: number): number {
  if (!level.timeLimit) return 0;

  const timeRemaining = level.timeLimit - timeUsed;
  const bonusPerSecond = 5;

  return Math.floor(timeRemaining * bonusPerSecond);
}
```

---

## 12. 物理引擎

### 12.1 游戏循环
```javascript
function gameLoop(timestamp: number): void {
  const deltaTime = (timestamp - lastTimestamp) / 1000;
  lastTimestamp = timestamp;

  // 更新狼的位置
  updateWolves(deltaTime);

  // 更新狼的AI
  updateWolvesAI();

  // 碰撞检测
  checkCollisions();

  // 更新游戏状态
  updateGameState();

  // 渲染
  render();

  // 下一帧
  requestAnimationFrame(gameLoop);
}
```

### 12.2 更新狼
```javascript
function updateWolves(deltaTime: number): void {
  wolves.forEach(wolf => {
    if (wolf.isRunning) {
      moveWolf(wolf, deltaTime);
      updateTrail(wolf);
    }
  });
}
```

### 12.3 渲染
```javascript
function render(): void {
  // 清空画布
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 绘制背景
  drawBackground();

  // 绘制障碍物
  obstacles.forEach(obstacle => {
    drawObstacle(obstacle);
  });

  // 绘制菜狗
  drawDog(dog);

  // 绘制狼
  wolves.forEach(wolf => {
    drawWolf(wolf);
  });

  // 绘制轨迹
  trails.forEach(trail => {
    drawTrail(trail);
  });

  // 绘制UI
  drawUI();
}
```

---

## 13. 性能优化

### 13.1 对象池
```javascript
class ObjectPool<T> {
  private pool: T[] = [];
  private factory: () => T;

  constructor(factory: () => T, initialSize: number = 10) {
    this.factory = factory;
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(factory());
    }
  }

  acquire(): T {
    return this.pool.pop() || this.factory();
  }

  release(obj: T): void {
    this.pool.push(obj);
  }
}
```

### 13.2 空间分区
```javascript
class SpatialPartition {
  private grid: Map<string, Entity[]> = new Map();
  private cellSize: number;

  constructor(cellSize: number = 100) {
    this.cellSize = cellSize;
  }

  add(entity: Entity): void {
    const key = this.getKey(entity);
    if (!this.grid.has(key)) {
      this.grid.set(key, []);
    }
    this.grid.get(key)!.push(entity);
  }

  getNearby(entity: Entity): Entity[] {
    const key = this.getKey(entity);
    return this.grid.get(key) || [];
  }

  private getKey(entity: Entity): string {
    const x = Math.floor(entity.x / this.cellSize);
    const y = Math.floor(entity.y / this.cellSize);
    return `${x},${y}`;
  }
}
```

### 13.3 帧率控制
```javascript
class FrameRateController {
  private targetFPS: number = 60;
  private frameTime: number = 1000 / this.targetFPS;
  private lastTime: number = 0;

  update(callback: () => void): void {
    const currentTime = performance.now();
    const deltaTime = currentTime - this.lastTime;

    if (deltaTime >= this.frameTime) {
      this.lastTime = currentTime - (deltaTime % this.frameTime);
      callback();
    }

    requestAnimationFrame(() => this.update(callback));
  }
}
```

---

## 14. 数据持久化

### 14.1 保存游戏进度
```javascript
function saveGameProgress(progress: GameProgress): void {
  const data = JSON.stringify(progress);
  localStorage.setItem('gameProgress', data);
}
```

### 14.2 加载游戏进度
```javascript
function loadGameProgress(): GameProgress | null {
  const data = localStorage.getItem('gameProgress');
  if (!data) return null;

  try {
    return JSON.parse(data);
  } catch (error) {
    return null;
  }
}
```

### 14.3 游戏进度结构
```javascript
interface GameProgress {
  currentLevel: number;
  unlockedLevels: number[];
  highScores: Map<number, number>;
  totalScore: number;
  coins: number;
  unlockedSkins: string[];
  settings: GameSettings;
}
```

---

## 15. 特殊机制

### 15.1 狼的协作
```javascript
function updateWolfPackBehavior(wolves: Wolf[], dog: VegetableDog): void {
  // 狼群协作，从不同方向包围菜狗
  const directions = [Direction.LEFT_UP, Direction.LEFT_DOWN, Direction.RIGHT_UP, Direction.RIGHT_DOWN];
  
  wolves.forEach((wolf, index) => {
    if (wolf.state === WolfState.HUNTING) {
      // 分配不同的方向，形成包围
      wolf.direction = directions[index % directions.length];
    }
  });
}
```

### 15.2 菜狗的恐惧范围
```javascript
function updateDogFear(dog: VegetableDog, wolves: Wolf[]): void {
  const fearRange = 200; // 恐惧范围
  let nearbyWolves = 0;

  wolves.forEach(wolf => {
    const distance = getDistance(dog, wolf);
    if (distance < fearRange) {
      nearbyWolves++;
    }
  });

  // 根据附近狼的数量更新状态
  if (nearbyWolves >= 3) {
    dog.state = DogState.SCARED;
  } else if (nearbyWolves === 0) {
    dog.state = DogState.IDLE;
  }
}
```

### 15.3 保护道具
```javascript
interface ProtectionItem {
  id: string;
  type: ProtectionType;
  x: number;
  y: number;
  duration: number; // 保护持续时间
  isCollected: boolean;
}

enum ProtectionType {
  SHIELD = 'shield',     // 护盾
  BARRIER = 'barrier',   // 障碍
  TRAP = 'trap'         // 陷阱
}

function useProtectionItem(item: ProtectionItem, dog: VegetableDog): void {
  if (item.type === ProtectionType.SHIELD) {
    protectDog(dog, item.duration);
  } else if (item.type === ProtectionType.BARRIER) {
    createBarrier(item.x, item.y, item.duration);
  } else if (item.type === ProtectionType.TRAP) {
    createTrap(item.x, item.y);
  }
}
```

---

**文档版本**：v2.0
**最后更新**：2026-02-01
**负责人**：开发团队
